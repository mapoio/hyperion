# Story 2.2: GORM Database Adapter

## Status
**✅ Approved** (Approved: 2025-10-02, Created: 2025-10-02)

## Story
**As a** framework user,
**I want** production-ready database access using GORM with transaction management,
**so that** I can build robust data-driven applications with declarative transaction handling

## Acceptance Criteria
1. GORM adapter implements `hyperion.Database` interface
2. GORM adapter implements `hyperion.Executor` interface (wrapping GORM operations)
3. GORM adapter implements `hyperion.UnitOfWork` interface for declarative transactions
4. Support PostgreSQL, MySQL, and SQLite drivers
5. Transaction propagation works correctly via `hyperion.Context`
6. Configuration integration via `hyperion.Config`
7. Test coverage >= 80%
8. Integration tests with real databases (Docker)

## Tasks / Subtasks

- [ ] **Implement `gormDatabase` struct** (AC: 1)
  - [ ] Create struct wrapping `*gorm.DB`
  - [ ] Implement `Executor() Executor` method
  - [ ] Implement `Health(ctx context.Context) error` method
  - [ ] Implement `Close() error` method
  - [ ] Ensure interface compliance with `var _ hyperion.Database = (*gormDatabase)(nil)`
  - [ ] Document struct in godoc format

- [ ] **Implement `gormExecutor` struct** (AC: 2)
  - [ ] Create struct wrapping `*gorm.DB`
  - [ ] Implement `Exec(ctx context.Context, sql string, args ...any) error`
  - [ ] Implement `Query(ctx context.Context, dest any, sql string, args ...any) error`
  - [ ] Implement `Begin(ctx context.Context) (Executor, error)`
  - [ ] Implement `Commit() error` (track transaction state)
  - [ ] Implement `Rollback() error` (track transaction state)
  - [ ] Implement `Unwrap() any` to return underlying `*gorm.DB`
  - [ ] Add internal transaction state tracking (is this a tx or base db?)
  - [ ] Ensure interface compliance with `var _ hyperion.Executor = (*gormExecutor)(nil)`

- [ ] **Implement `gormUnitOfWork` struct** (AC: 3)
  - [ ] Create struct wrapping `*gorm.DB`
  - [ ] Implement `WithTransaction(ctx hyperion.Context, fn func(txCtx hyperion.Context) error) error`
  - [ ] Use `hyperion.WithDB()` to inject transaction executor into context
  - [ ] Handle automatic commit on success
  - [ ] Handle automatic rollback on error
  - [ ] Handle panic recovery with rollback
  - [ ] Implement `WithTransactionOptions(ctx hyperion.Context, opts *TransactionOptions, fn func(txCtx hyperion.Context) error) error`
  - [ ] Map `hyperion.IsolationLevel` to GORM/SQL isolation levels
  - [ ] Support read-only transactions
  - [ ] Ensure interface compliance with `var _ hyperion.UnitOfWork = (*gormUnitOfWork)(nil)`

- [ ] **Add database driver support** (AC: 4)
  - [ ] Add PostgreSQL driver support (`gorm.io/driver/postgres`)
  - [ ] Add MySQL driver support (`gorm.io/driver/mysql`)
  - [ ] Add SQLite driver support (`gorm.io/driver/sqlite`)
  - [ ] Implement driver selection based on config
  - [ ] Add connection string builder for each driver
  - [ ] Test connection with each driver

- [ ] **Add configuration integration** (AC: 6)
  - [ ] Define configuration structure for database settings
  - [ ] Read driver type from config (`database.driver`)
  - [ ] Read connection parameters from config (`database.host`, `database.port`, etc.)
  - [ ] Read connection pool settings from config (`database.max_open_conns`, etc.)
  - [ ] Read GORM settings from config (`database.log_level`, `database.slow_threshold`, etc.)
  - [ ] Provide sensible defaults when config missing
  - [ ] Support DSN (Data Source Name) format for quick setup

- [ ] **Create constructor with config support**
  - [ ] Implement `NewGormDatabase(cfg hyperion.Config) (hyperion.Database, error)`
  - [ ] Implement `NewGormUnitOfWork(db hyperion.Database) hyperion.UnitOfWork`
  - [ ] Handle missing config gracefully (use defaults or return error)
  - [ ] Validate configuration values (required fields, valid driver, etc.)
  - [ ] Return appropriate errors for invalid config
  - [ ] Test auto-migration support (optional via config)

- [ ] **Create `module.go` for fx integration**
  - [ ] Define `Module = fx.Module("hyperion.adapter.gorm", ...)`
  - [ ] Use `fx.Provide` with `fx.Annotate` for Database interface binding
  - [ ] Use `fx.Provide` with `fx.Annotate` for UnitOfWork interface binding
  - [ ] Bind to `hyperion.Database` interface using `fx.As(new(hyperion.Database))`
  - [ ] Bind to `hyperion.UnitOfWork` interface using `fx.As(new(hyperion.UnitOfWork))`
  - [ ] Add lifecycle hooks for graceful shutdown (`fx.Lifecycle`)
  - [ ] Document module usage in comments

- [ ] **Write unit tests** (>80% coverage) (AC: 7)
  - [ ] Test `gormDatabase` interface methods
  - [ ] Test `gormExecutor` Exec() and Query() methods
  - [ ] Test `gormExecutor` transaction methods (Begin/Commit/Rollback)
  - [ ] Test `gormExecutor` Unwrap() returns correct type
  - [ ] Test `gormUnitOfWork` WithTransaction() commit path
  - [ ] Test `gormUnitOfWork` WithTransaction() rollback on error
  - [ ] Test `gormUnitOfWork` WithTransaction() rollback on panic
  - [ ] Test `gormUnitOfWork` WithTransactionOptions() with isolation levels
  - [ ] Test `gormUnitOfWork` WithTransactionOptions() with read-only flag
  - [ ] Test config parsing and validation
  - [ ] Test driver selection logic
  - [ ] Use table-driven tests where appropriate
  - [ ] Place tests in `adapter/gorm/database_test.go`
  - [ ] Place tests in `adapter/gorm/executor_test.go`
  - [ ] Place tests in `adapter/gorm/unit_of_work_test.go`

- [ ] **Write integration tests** (AC: 8)
  - [ ] Set up Docker Compose for test databases (PostgreSQL, MySQL)
  - [ ] Test PostgreSQL connection and queries
  - [ ] Test MySQL connection and queries
  - [ ] Test SQLite in-memory database
  - [ ] Test transaction commit with real database
  - [ ] Test transaction rollback with real database
  - [ ] Test nested transaction behavior (savepoints)
  - [ ] Test concurrent transactions (race detection)
  - [ ] Test connection pool limits
  - [ ] Test Health() method with real connection
  - [ ] Place integration tests in `adapter/gorm/integration_test.go`

- [ ] **Write godoc documentation** (AC: all)
  - [ ] Create `adapter/gorm/doc.go` with package-level documentation
  - [ ] Document all exported types and functions
  - [ ] Include usage examples in documentation
  - [ ] Add transaction usage examples
  - [ ] Add configuration examples
  - [ ] Follow godoc conventions

- [ ] **Create README.md for adapter**
  - [ ] Installation instructions
  - [ ] Quick start example
  - [ ] Configuration reference
  - [ ] Transaction patterns and best practices
  - [ ] Supported databases and versions
  - [ ] Performance considerations
  - [ ] Migration guide (if applicable)

- [ ] **Performance benchmarking**
  - [ ] Benchmark Executor overhead vs native GORM
  - [ ] Benchmark transaction overhead
  - [ ] Verify <5% performance overhead requirement
  - [ ] Document benchmark results in IMPLEMENTATION_REPORT.md

## Dev Notes

### Architecture Context

This story implements the **GORM Database Adapter**, which provides production-ready database access with declarative transaction management as the second essential adapter in Epic 2. It wraps the GORM v2 library to implement the `hyperion.Database`, `hyperion.Executor`, and `hyperion.UnitOfWork` interfaces defined in Epic 1.

[Source: docs/prd/epic-2-essential-adapters.md#2-gorm-database-adapter]

### Technology Stack

**Library: GORM v2** (`gorm.io/gorm`)
- Most popular Go ORM with excellent plugin ecosystem
- Support for multiple databases (PostgreSQL, MySQL, SQLite, SQL Server, etc.)
- Advanced features: Associations, Transactions, Hooks, Context support
- Active development and strong community

**Planned Version**: `gorm.io/gorm v1.25.0+`

[Source: docs/architecture/tech-stack.md#database-gorm-adaptergorm]

**Database Drivers**:
- `gorm.io/driver/postgres` - PostgreSQL driver
- `gorm.io/driver/mysql` - MySQL driver
- `gorm.io/driver/sqlite` - SQLite driver

### Core Interfaces to Implement

The adapter must implement three interfaces:

**1. Database Interface** (`hyperion/database.go`):
```go
type Database interface {
    Executor() Executor
    Health(ctx context.Context) error
    Close() error
}
```

**2. Executor Interface** (`hyperion/database.go`):
```go
type Executor interface {
    Exec(ctx context.Context, sql string, args ...any) error
    Query(ctx context.Context, dest any, sql string, args ...any) error
    Begin(ctx context.Context) (Executor, error)
    Commit() error
    Rollback() error
    Unwrap() any
}
```

**3. UnitOfWork Interface** (`hyperion/database.go`):
```go
type UnitOfWork interface {
    WithTransaction(ctx Context, fn func(txCtx Context) error) error
    WithTransactionOptions(ctx Context, opts *TransactionOptions, fn func(txCtx Context) error) error
}
```

[Source: hyperion/database.go]

### File Locations & Structure

**Package Location**: `adapter/gorm/`

**File Structure** (based on source tree guide):
```
adapter/gorm/
├── go.mod                 # Independent module
├── go.sum
├── database.go            # gormDatabase implementation
├── executor.go            # gormExecutor implementation
├── unit_of_work.go        # gormUnitOfWork implementation
├── config.go              # Configuration structures
├── module.go              # fx.Module export
├── database_test.go       # Database tests
├── executor_test.go       # Executor tests
├── unit_of_work_test.go   # UnitOfWork tests
├── integration_test.go    # Integration tests
├── doc.go                 # Package documentation
├── README.md              # Usage documentation
└── docker-compose.test.yml # Test database setup
```

[Source: docs/architecture/source-tree.md#adapter-packages]

### Implementation Design

**gormDatabase Struct**:
```go
type gormDatabase struct {
    db *gorm.DB
}

func (d *gormDatabase) Executor() hyperion.Executor {
    return &gormExecutor{db: d.db, isTx: false}
}

func (d *gormDatabase) Health(ctx context.Context) error {
    sqlDB, err := d.db.DB()
    if err != nil {
        return fmt.Errorf("failed to get sql.DB: %w", err)
    }
    return sqlDB.PingContext(ctx)
}

func (d *gormDatabase) Close() error {
    sqlDB, err := d.db.DB()
    if err != nil {
        return fmt.Errorf("failed to get sql.DB: %w", err)
    }
    return sqlDB.Close()
}
```

**gormExecutor Struct**:
```go
type gormExecutor struct {
    db   *gorm.DB
    isTx bool  // Track if this is a transaction
}

func (e *gormExecutor) Exec(ctx context.Context, sql string, args ...any) error {
    return e.db.WithContext(ctx).Exec(sql, args...).Error
}

func (e *gormExecutor) Query(ctx context.Context, dest any, sql string, args ...any) error {
    return e.db.WithContext(ctx).Raw(sql, args...).Scan(dest).Error
}

func (e *gormExecutor) Begin(ctx context.Context) (hyperion.Executor, error) {
    tx := e.db.WithContext(ctx).Begin()
    if tx.Error != nil {
        return nil, tx.Error
    }
    return &gormExecutor{db: tx, isTx: true}, nil
}

func (e *gormExecutor) Commit() error {
    if !e.isTx {
        return fmt.Errorf("not in transaction")
    }
    return e.db.Commit().Error
}

func (e *gormExecutor) Rollback() error {
    if !e.isTx {
        return fmt.Errorf("not in transaction")
    }
    return e.db.Rollback().Error
}

func (e *gormExecutor) Unwrap() any {
    return e.db
}
```

**gormUnitOfWork Struct**:
```go
type gormUnitOfWork struct {
    db *gorm.DB
}

func (u *gormUnitOfWork) WithTransaction(ctx hyperion.Context, fn func(txCtx hyperion.Context) error) error {
    return u.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // Create transaction executor
        txExecutor := &gormExecutor{db: tx, isTx: true}

        // Inject into context
        txCtx := hyperion.WithDB(ctx, txExecutor)

        // Execute user function
        return fn(txCtx)
    })
}

func (u *gormUnitOfWork) WithTransactionOptions(ctx hyperion.Context, opts *hyperion.TransactionOptions, fn func(txCtx hyperion.Context) error) error {
    gormOpts := &sql.TxOptions{
        Isolation: toSQLIsolation(opts.Isolation),
        ReadOnly:  opts.ReadOnly,
    }

    return u.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        txExecutor := &gormExecutor{db: tx, isTx: true}
        txCtx := hyperion.WithDB(ctx, txExecutor)
        return fn(txCtx)
    }, gormOpts)
}
```

[Source: docs/prd/epic-2-essential-adapters.md#interface-implementation]

### Configuration Specification

**Configuration Structure**:
```yaml
database:
  driver: postgres           # postgres, mysql, sqlite
  host: localhost
  port: 5432
  username: dbuser
  password: dbpass
  database: mydb
  sslmode: disable           # PostgreSQL specific
  charset: utf8mb4           # MySQL specific

  # Connection pool settings
  max_open_conns: 25
  max_idle_conns: 5
  conn_max_lifetime: 5m
  conn_max_idle_time: 10m

  # GORM settings
  log_level: warn            # silent, error, warn, info
  slow_threshold: 200ms
  skip_default_transaction: false
  prepare_stmt: true

  # Auto migration (optional)
  auto_migrate: false
```

**Config Keys**:
- `database.driver` → "postgres", "mysql", or "sqlite"
- `database.host`, `database.port`, `database.database` → Connection params
- `database.max_open_conns` → Maximum open connections
- `database.max_idle_conns` → Maximum idle connections
- `database.log_level` → GORM log level

**Alternative DSN Format**:
```yaml
database:
  dsn: "postgres://user:pass@localhost:5432/dbname?sslmode=disable"
  driver: postgres  # Still required for driver selection
```

[Source: docs/prd/epic-2-essential-adapters.md#configuration-example]

### Module Export Pattern

The adapter must export an fx.Module with lifecycle management:

```go
// module.go
package gorm

import (
    "context"
    "go.uber.org/fx"
    "github.com/mapoio/hyperion"
)

var Module = fx.Module("hyperion.adapter.gorm",
    fx.Provide(
        fx.Annotate(
            NewGormDatabase,
            fx.As(new(hyperion.Database)),
        ),
        fx.Annotate(
            NewGormUnitOfWork,
            fx.As(new(hyperion.UnitOfWork)),
        ),
    ),
    fx.Invoke(registerLifecycle),
)

func registerLifecycle(lc fx.Lifecycle, db hyperion.Database) {
    lc.Append(fx.Hook{
        OnStop: func(ctx context.Context) error {
            return db.Close()
        },
    })
}
```

[Source: docs/architecture/source-tree.md#adapter-module-pattern]

### Dependencies

**Required Go modules**:
- `gorm.io/gorm` v1.25.0+ - ORM library
- `gorm.io/driver/postgres` - PostgreSQL driver
- `gorm.io/driver/mysql` - MySQL driver
- `gorm.io/driver/sqlite` - SQLite driver
- `go.uber.org/fx` - Dependency injection (from core)
- `github.com/mapoio/hyperion` - Core interfaces

**Module Declaration** (`adapter/gorm/go.mod`):
```
module github.com/mapoio/hyperion/adapter/gorm

go 1.24

require (
    github.com/mapoio/hyperion v0.0.0
    gorm.io/gorm v1.25.0
    gorm.io/driver/postgres v1.5.0
    gorm.io/driver/mysql v1.5.0
    gorm.io/driver/sqlite v1.5.0
    go.uber.org/fx v1.24.0
)
```

**Workspace Integration**:
After creating the module, add to workspace:
```bash
go work use ./adapter/gorm
```

[Source: docs/architecture/source-tree.md#adding-a-new-adapter]

### Transaction Propagation Pattern

**Key Design Decision**: Use `hyperion.WithDB()` helper function to inject transaction executor into context.

**User Code Example**:
```go
type UserService struct {
    uow      hyperion.UnitOfWork
    userRepo *UserRepository
}

func (s *UserService) RegisterUser(ctx hyperion.Context, req RegisterRequest) error {
    return s.uow.WithTransaction(ctx, func(txCtx hyperion.Context) error {
        // txCtx.DB() returns transaction executor
        user := &User{Email: req.Email}
        if err := s.userRepo.Create(txCtx, user); err != nil {
            return err  // Auto-rollback
        }

        profile := &Profile{UserID: user.ID}
        if err := s.profileRepo.Create(txCtx, profile); err != nil {
            return err  // Auto-rollback
        }

        return nil  // Auto-commit
    })
}
```

**Repository Pattern** (uses `txCtx.DB()`):
```go
type UserRepository struct {}

func (r *UserRepository) Create(ctx hyperion.Context, user *User) error {
    db := ctx.DB().Unwrap().(*gorm.DB)  // Get GORM instance
    return db.Create(user).Error
}
```

[Source: docs/prd/epic-2-essential-adapters.md#transaction-example]

### Testing Requirements

**Test Coverage**: >= 80% (as specified in AC 7)

[Source: docs/prd/epic-2-essential-adapters.md#success-criteria]

**Unit Test Location**: `adapter/gorm/*_test.go`

**Integration Test Requirements**:
- Use Docker Compose to spin up test databases
- Test with PostgreSQL 14+
- Test with MySQL 8.0+
- Test with SQLite (in-memory)
- Run integration tests with `-tags=integration` build tag

**Docker Compose for Testing** (`docker-compose.test.yml`):
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: test
      POSTGRES_PASSWORD: test
      POSTGRES_DB: hyperion_test
    ports:
      - "5432:5432"

  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: test
      MYSQL_DATABASE: hyperion_test
    ports:
      - "3306:3306"
```

**Test Structure Example**:
```go
func TestGormDatabase_Health(t *testing.T) {
    cfg := &mockConfig{
        data: map[string]any{
            "database": map[string]any{
                "driver":   "sqlite",
                "database": ":memory:",
            },
        },
    }

    db, err := NewGormDatabase(cfg)
    if err != nil {
        t.Fatalf("NewGormDatabase() error = %v", err)
    }
    defer db.Close()

    if err := db.Health(context.Background()); err != nil {
        t.Errorf("Health() error = %v, want nil", err)
    }
}
```

[Source: docs/architecture/coding-standards.md#testing]
[Source: docs/architecture.md#13-testing-strategy]

### Performance Expectations

**Expected Performance** (from tech stack):
- **Overhead**: < 5% vs native GORM
- **Transaction latency**: < 1ms additional overhead
- **Query throughput**: Maintain GORM's native performance

**Benchmark Targets**:
```
BenchmarkExecutor_Query     10000 ops/s  (vs GORM: 10500 ops/s) = 4.8% overhead ✅
BenchmarkUnitOfWork_Tx       5000 ops/s  (vs GORM:  5200 ops/s) = 3.8% overhead ✅
```

[Source: docs/architecture/tech-stack.md#adapter-performance-expected]
[Source: docs/prd/epic-2-essential-adapters.md#success-criteria]

### Isolation Level Mapping

Map `hyperion.IsolationLevel` to SQL isolation levels:

```go
func toSQLIsolation(level hyperion.IsolationLevel) sql.IsolationLevel {
    switch level {
    case hyperion.IsolationLevelDefault:
        return sql.LevelDefault
    case hyperion.IsolationLevelReadUncommitted:
        return sql.LevelReadUncommitted
    case hyperion.IsolationLevelReadCommitted:
        return sql.LevelReadCommitted
    case hyperion.IsolationLevelRepeatableRead:
        return sql.LevelRepeatableRead
    case hyperion.IsolationLevelSerializable:
        return sql.LevelSerializable
    default:
        return sql.LevelDefault
    }
}
```

### Critical Design Decisions

**1. Executor vs Repository Pattern**
- **Decision**: Provide low-level `Executor` interface, let users build Repository layer
- **Rationale**: Executor is thin wrapper around GORM; users can access native GORM via `Unwrap()`
- **Trade-off**: More boilerplate in user code, but maximum flexibility

**2. Transaction State Tracking**
- **Decision**: Use `isTx bool` field to track if executor is a transaction
- **Rationale**: Prevents calling `Commit()`/`Rollback()` on non-transaction executors
- **Alternative**: Use separate types for base executor and transaction executor

**3. GORM Version Support**
- **Decision**: Support GORM v2 only (v1.25.0+)
- **Rationale**: GORM v2 has better context support, cleaner API, active development
- **Migration Path**: Users on GORM v1 should migrate to v2 first

**4. Nested Transaction Handling**
- **Decision**: Rely on GORM's built-in savepoint support for nested transactions
- **Behavior**: Nested `WithTransaction()` calls create savepoints automatically
- **Limitation**: Savepoints not supported on all databases (e.g., some SQLite configs)

### Related Stories

**Previous Story**:
- Story 2.1: Zap Logger Adapter (✅ Completed)
- Provides logging infrastructure for database adapter

**Current Story**:
- Story 2.2: GORM Database Adapter (Current)
- Provides database access and transaction management

**Next Story**:
- Story 2.3: Production Context Implementation (Planned)
- Integrates Logger, Database, and Tracer into working Context
- Story 2.4: Example CRUD Application (Planned)
- Demonstrates complete usage of Zap + GORM adapters

[Source: docs/prd/epic-2-essential-adapters.md#deliverables]

### Success Validation

Story is complete when:
1. ✅ All acceptance criteria met (8/8)
2. ✅ Test coverage >= 80%
3. ✅ All linters pass (`make lint`)
4. ✅ All tests pass (`make test`)
5. ✅ Integration tests pass with real databases
6. ✅ Documentation complete (godoc + README)
7. ✅ Integration with fx.Module working
8. ✅ Performance overhead < 5% vs native GORM

[Source: docs/prd/epic-2-essential-adapters.md#success-criteria]

---

**Story Timeline**: 10 working days (as per Epic 2 plan)
**Priority**: P0 (Essential adapter)
**Assigned To**: Developer Agent
**Epic**: Epic 2 - Essential Adapters (v2.1)

---

## Implementation Checklist

Before starting development, ensure:

- [ ] Epic 2 PRD reviewed and understood
- [ ] Story 2.1 (Zap) completed and merged
- [ ] GORM v2 documentation reviewed
- [ ] Database interface contract understood
- [ ] Transaction propagation pattern clear
- [ ] Test database setup planned (Docker Compose)
- [ ] Performance benchmarking approach defined

**Ready to begin implementation?** Type "Yes" to proceed or review the story first.
