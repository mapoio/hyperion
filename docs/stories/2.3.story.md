# Story 2.3: Production Context Implementation with Decorator Support

## Status
**📝 Draft** (Created: 2025-10-03)

## Story
**As a** framework user,
**I want** a production-ready Context implementation with decorator pattern support and fx integration,
**so that** I can build applications with clean AOP-style cross-cutting concerns (logging, tracing, transactions)

## Acceptance Criteria
1. Context factory function integrates with fx dependency injection
2. Decorator pattern infrastructure supports wrapping Logger, Tracer, and Executor
3. Context constructors provided via fx.Module for easy integration
4. WithLogger(), WithTracer(), WithDB() helpers create immutable context copies
5. NewContextFactory() provides a clean way to build contexts from fx-injected dependencies
6. Middleware/interceptor foundation supports AOP-style cross-cutting concerns
7. Test coverage >= 80%
8. Documentation includes decorator pattern examples

## Tasks / Subtasks

- [ ] **Implement Context Factory for fx Integration** (AC: 1, 5)
  - [ ] Create `NewContextFactory(logger Logger, tracer Tracer, db Database) ContextFactory` constructor
  - [ ] Define `ContextFactory` interface with `New(ctx context.Context) Context` method
  - [ ] Implement `contextFactory` struct that captures injected dependencies
  - [ ] Ensure factory can be injected via fx.Provide
  - [ ] Add godoc explaining factory pattern usage

- [ ] **Add Decorator Pattern Infrastructure** (AC: 2, 6)
  - [ ] Define `LoggerDecorator` interface: `type LoggerDecorator func(Logger) Logger`
  - [ ] Define `TracerDecorator` interface: `type TracerDecorator func(Tracer) Tracer`
  - [ ] Define `ExecutorDecorator` interface: `type ExecutorDecorator func(Executor) Executor`
  - [ ] Implement `WithLoggerDecorator(decorators ...LoggerDecorator) Option` for factory
  - [ ] Implement `WithTracerDecorator(decorators ...TracerDecorator) Option` for factory
  - [ ] Implement `WithExecutorDecorator(decorators ...ExecutorDecorator) Option` for factory
  - [ ] Update factory to apply decorators when creating contexts
  - [ ] Add godoc examples showing decorator usage for AOP patterns

- [ ] **Implement Context Helper Functions** (AC: 4)
  - [ ] Enhance `WithDB(ctx Context, db Executor) Context` (already exists)
  - [ ] Add `WithLogger(ctx Context, logger Logger) Context` for logger replacement
  - [ ] Add `WithTracer(ctx Context, tracer Tracer) Context` for tracer replacement
  - [ ] Ensure all helpers return new immutable context instances
  - [ ] Add type assertions with fallback to New() for non-hyperionContext types
  - [ ] Document immutability guarantees in godoc

- [ ] **Create fx.Module for Context** (AC: 3)
  - [ ] Define `ContextModule = fx.Module("hyperion.context", ...)`
  - [ ] Use `fx.Provide` to register `NewContextFactory`
  - [ ] Add `fx.Annotate` to bind factory to interface (if needed)
  - [ ] Integrate ContextModule into CoreModule in `hyperion/module.go`
  - [ ] Document module usage in godoc with fx.New() example

- [ ] **Add Middleware/Interceptor Foundation** (AC: 6)
  - [ ] Define `ContextMiddleware` type: `type ContextMiddleware func(Context, func(Context) error) error`
  - [ ] Implement `ChainMiddleware(middlewares ...ContextMiddleware) ContextMiddleware` combiner
  - [ ] Add example middleware implementations in tests (LoggingMiddleware, TracingMiddleware)
  - [ ] Document middleware pattern for service layer AOP
  - [ ] Add examples showing how to wrap service methods with middleware

- [ ] **Write Unit Tests** (AC: 7)
  - [ ] Test `NewContextFactory` with all dependencies
  - [ ] Test factory `New()` method creates valid contexts
  - [ ] Test decorator application (logger, tracer, executor)
  - [ ] Test `WithLogger()`, `WithTracer()`, `WithDB()` helpers
  - [ ] Test immutability of context after helper calls
  - [ ] Test middleware chaining with `ChainMiddleware`
  - [ ] Test decorator composition (multiple decorators)
  - [ ] Use table-driven tests where appropriate
  - [ ] Achieve >= 80% test coverage
  - [ ] Place tests in `hyperion/context_test.go`

- [ ] **Write Documentation and Examples** (AC: 8)
  - [ ] Add package-level godoc explaining Context philosophy
  - [ ] Document decorator pattern with AOP examples
  - [ ] Add example: Logging decorator that logs all Logger calls
  - [ ] Add example: Tracing decorator that adds span attributes
  - [ ] Add example: Executor decorator for query logging
  - [ ] Add example: Service layer middleware for request tracing
  - [ ] Update `hyperion/context.go` godoc with factory usage
  - [ ] Add migration guide from basic New() to factory pattern

- [ ] **Integrate with CoreModule** (AC: 3)
  - [ ] Update `hyperion/module.go` to include ContextModule
  - [ ] Verify no circular dependencies
  - [ ] Test CoreModule provides ContextFactory
  - [ ] Verify factory works with existing adapter modules (zap, gorm)

## Dev Notes

### Architecture Context

This story enhances the **Production Context** implementation to support:
1. **Dependency Injection**: Factory pattern for clean fx integration
2. **Decorator Pattern**: AOP-style cross-cutting concerns without modifying core logic
3. **Immutability**: Safe context manipulation via helper functions
4. **Middleware Foundation**: Service-layer interceptors for logging, tracing, transactions

Current `hyperion/context.go` (112 lines) provides basic Context interface and `hyperionContext` struct, but lacks:
- fx integration (factory pattern)
- Decorator support for AOP
- Middleware infrastructure

[Source: docs/prd/epic-2-essential-adapters.md#3-production-context-implementation]

### Existing Implementation

**Current Context Interface** (`hyperion/context.go:8-33`):
```go
type Context interface {
    context.Context
    Logger() Logger
    DB() Executor
    Tracer() Tracer
    WithTimeout(timeout time.Duration) (Context, context.CancelFunc)
    WithCancel() (Context, context.CancelFunc)
    WithDeadline(deadline time.Time) (Context, context.CancelFunc)
}
```

**Current Constructor** (`hyperion/context.go:36-48`):
```go
func New(ctx context.Context, logger Logger, db Executor, tracer Tracer) Context {
    return &hyperionContext{
        Context: ctx,
        logger:  logger,
        db:      db,
        tracer:  tracer,
    }
}
```

**Current Struct** (`hyperion/context.go:50-68`):
```go
type hyperionContext struct {
    context.Context
    logger Logger
    db     Executor
    tracer Tracer
}
```

**Existing Helper** (`hyperion/context.go:98-111`):
```go
func WithDB(ctx Context, db Executor) Context {
    // Already implemented - creates new context with different DB
}
```

[Source: hyperion/context.go]

### Decorator Pattern Design

**Why Decorators for AOP?**

Decorator pattern enables AOP-style cross-cutting concerns without framework lock-in:

```go
// Example: Logging decorator
func LoggingDecorator(logger Logger) Logger {
    return &loggingDecorator{
        wrapped: logger,
        prefix:  "[APP]",
    }
}

// Example: Executor decorator for query logging
func QueryLoggingDecorator(logger Logger) ExecutorDecorator {
    return func(exec Executor) Executor {
        return &queryLoggingExecutor{
            wrapped: exec,
            logger:  logger,
        }
    }
}

// Usage in fx app:
factory := NewContextFactory(
    logger,
    tracer,
    db,
    WithExecutorDecorator(QueryLoggingDecorator(logger)),
)
```

This pattern allows users to:
- Add logging without modifying Logger implementation
- Add tracing metadata without changing Tracer
- Add query logging without touching GORM adapter
- Stack multiple decorators (composition)

[Source: Go Design Patterns - Decorator Pattern]

### Factory Pattern for fx Integration

**Current Problem**: `New()` requires manual dependency wiring:
```go
// Hard to use in fx apps - requires manual wiring
ctx := hyperion.New(stdCtx, logger, db.Executor(), tracer)
```

**Solution**: Factory pattern with fx integration:
```go
// In fx app - automatic dependency injection
type ContextFactory interface {
    New(ctx context.Context) Context
}

func NewContextFactory(logger Logger, tracer Tracer, db Database) ContextFactory {
    return &contextFactory{
        logger: logger,
        tracer: tracer,
        db:     db,
    }
}

// fx.Module
var ContextModule = fx.Module("hyperion.context",
    fx.Provide(NewContextFactory),
)

// Usage in handler (injected factory):
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    ctx := h.factory.New(r.Context())  // Clean!
    ctx.Logger().Info("handling request")
}
```

[Source: fx documentation - Provider Pattern]

### Middleware Foundation

**Service Layer Middleware Pattern**:

```go
type ContextMiddleware func(Context, func(Context) error) error

// Logging middleware
func LoggingMiddleware(ctx Context, next func(Context) error) error {
    ctx.Logger().Info("service call started")
    err := next(ctx)
    if err != nil {
        ctx.Logger().Error("service call failed", "error", err)
    }
    return err
}

// Tracing middleware
func TracingMiddleware(ctx Context, next func(Context) error) error {
    _, span := ctx.Tracer().Start(ctx, "service-operation")
    defer span.End()
    return next(ctx)
}

// Chain multiple middleware
chain := ChainMiddleware(LoggingMiddleware, TracingMiddleware)

// Apply to service method
err := chain(ctx, func(ctx Context) error {
    return service.DoWork(ctx)
})
```

This foundation enables future Epic 4 (Web Framework) to build HTTP middleware on top.

[Source: Go middleware patterns - Decorator + Chain of Responsibility]

### File Locations & Structure

**Modified Files**:
- `hyperion/context.go` - Add factory, decorators, helpers
- `hyperion/module.go` - Add ContextModule to CoreModule

**New Files**:
- `hyperion/context_factory.go` - Factory implementation
- `hyperion/context_decorator.go` - Decorator types and helpers
- `hyperion/context_middleware.go` - Middleware foundation
- `hyperion/context_test.go` - Enhanced tests
- `hyperion/context_factory_test.go` - Factory tests
- `hyperion/context_decorator_test.go` - Decorator tests
- `hyperion/context_middleware_test.go` - Middleware tests

[Source: docs/architecture/source-tree.md#core-library]

### Core Module Integration

**Current CoreModule** (`hyperion/module.go:23-35`):
```go
var CoreModule = fx.Module("hyperion.core",
    fx.Options(
        DefaultLoggerModule,
        DefaultTracerModule,
        DefaultDatabaseModule,
        DefaultConfigModule,
        DefaultCacheModule,
    ),
)
```

**Enhanced CoreModule** (after this story):
```go
var CoreModule = fx.Module("hyperion.core",
    fx.Options(
        DefaultLoggerModule,
        DefaultTracerModule,
        DefaultDatabaseModule,
        DefaultConfigModule,
        DefaultCacheModule,
        ContextModule,  // NEW: Provides ContextFactory
    ),
)
```

[Source: hyperion/module.go]

### Dependencies

**Required Go modules** (already in hyperion/go.mod):
- `go.uber.org/fx` - Dependency injection
- Standard library only (context, time)

**No new dependencies required** - decorators use pure Go interfaces.

[Source: hyperion/go.mod]

### Testing Requirements

**Test Coverage**: >= 80% (AC 7)

**Unit Test Structure**:
- `context_test.go` - Existing tests (covers New(), WithDB(), accessors)
- `context_factory_test.go` - Factory creation and usage
- `context_decorator_test.go` - Decorator application and composition
- `context_middleware_test.go` - Middleware chaining and execution

**Test Scenarios**:
1. Factory creates valid contexts with injected dependencies
2. Decorators wrap and extend behavior
3. Multiple decorators compose correctly (order matters)
4. Helpers create immutable copies
5. Middleware chains execute in correct order
6. Middleware can modify context (e.g., add tracing span)

[Source: docs/architecture/coding-standards.md#testing]

### Design Decisions

**1. Factory vs Direct Constructor**
- **Decision**: Provide both `New()` and `NewContextFactory()`
- **Rationale**: `New()` is simple for tests, factory for fx apps
- **Trade-off**: Two ways to create contexts (documented clearly)

**2. Decorator as Function Type**
- **Decision**: `type LoggerDecorator func(Logger) Logger` (not interface)
- **Rationale**: Simpler syntax, easier to compose
- **Alternative**: Interface-based decorators (more verbose)

**3. Middleware Pattern**
- **Decision**: Service-layer middleware (not HTTP middleware)
- **Rationale**: Framework-agnostic, works with any Context user
- **Future**: HTTP middleware in Epic 4 can build on this

**4. Immutability**
- **Decision**: All helpers (`WithLogger()`, etc.) return new Context
- **Rationale**: Prevents accidental mutation, thread-safe
- **Enforcement**: Document clearly, test immutability

### Related Stories

**Previous Stories**:
- Story 2.1: Zap Logger Adapter (✅ Completed) - Provides Logger implementation
- Story 2.2: GORM Database Adapter (✅ Completed) - Provides Database and Executor

**Current Story**:
- Story 2.3: Production Context Implementation (Current)
- Integrates Logger, Database, Tracer into working Context with AOP support

**Next Stories**:
- Story 2.4: Example CRUD Application (Planned) - Demonstrates Context usage
- Story 2.5: Integration Testing (Planned) - End-to-end validation

[Source: docs/prd/epic-2-essential-adapters.md#deliverables]

### Success Validation

Story is complete when:
1. ✅ ContextFactory integrates with fx.Provide pattern
2. ✅ Decorators successfully wrap Logger, Tracer, Executor
3. ✅ CoreModule provides ContextFactory automatically
4. ✅ All helpers create immutable context copies
5. ✅ Middleware foundation works with example implementations
6. ✅ Test coverage >= 80%
7. ✅ All linters pass (`make lint`)
8. ✅ All tests pass (`make test`)
9. ✅ Documentation includes AOP decorator examples

[Source: docs/prd/epic-2-essential-adapters.md#success-criteria]

---

## Testing

### Test File Locations
- `hyperion/context_test.go` - Core context tests (existing, enhance)
- `hyperion/context_factory_test.go` - Factory pattern tests (new)
- `hyperion/context_decorator_test.go` - Decorator pattern tests (new)
- `hyperion/context_middleware_test.go` - Middleware tests (new)

[Source: docs/architecture/source-tree.md#core-library]

### Testing Standards

**Framework**: Go standard `testing` package

**Test Naming**:
- `TestContextFactory_New` - Factory creation
- `TestWithLogger` - Helper functions
- `TestLoggerDecorator` - Decorator application
- `TestChainMiddleware` - Middleware composition

**Table-Driven Tests**: Use for testing multiple decorator combinations

**Assertion Style**: Explicit error messages (`t.Errorf("got %v, want %v", got, want)`)

[Source: docs/architecture/coding-standards.md#testing]

### Test Coverage Target
- Minimum: 80% (AC requirement)
- Target: 90%+ (critical infrastructure)
- Measure with: `go test -cover -coverprofile=coverage.out`

---

**Story Timeline**: 3 working days (as per Epic 2 plan)
**Priority**: P0 (Core infrastructure)
**Assigned To**: Developer Agent
**Epic**: Epic 2 - Essential Adapters (v2.1)

---

## Change Log

| Date       | Version | Description              | Author        |
|------------|---------|--------------------------|---------------|
| 2025-10-03 | 1.0     | Initial story creation with decorator pattern and fx integration focus | Scrum Master |

---

## Dev Agent Record

_(This section will be populated by the Developer Agent during implementation)_

### Agent Model Used

_(To be filled by Dev Agent)_

### Debug Log References

_(To be filled by Dev Agent)_

### Completion Notes

_(To be filled by Dev Agent)_

### File List

_(To be filled by Dev Agent)_

---

## QA Results

_(This section will be populated by QA Agent after implementation review)_
